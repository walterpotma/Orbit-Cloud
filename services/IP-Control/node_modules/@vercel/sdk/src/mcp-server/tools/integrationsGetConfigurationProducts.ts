/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { integrationsGetConfigurationProducts } from "../../funcs/integrationsGetConfigurationProducts.js";
import { GetConfigurationProductsRequest$inboundSchema } from "../../models/getconfigurationproductsop.js";
import { formatResult, ToolDefinition } from "../tools.js";

const args = {
  request: GetConfigurationProductsRequest$inboundSchema,
};

export const tool$integrationsGetConfigurationProducts: ToolDefinition<
  typeof args
> = {
  name: "integrations-get-configuration-products",
  description: `List products for integration configuration

Lists all products available for an integration configuration. Use this endpoint to discover what integration products are available for your integration configuration. The returned product IDs or slugs can then be used with storage provisioning endpoints like \`POST /v1/storage/stores/integration/direct\`. ## Workflow 1. Get your integration configurations: \`GET /v1/integrations/configurations\` 2. **Use this endpoint**: Get products for a configuration: \`GET /v1/integrations/configuration/{id}/products\` 3. Create storage resource: \`POST /v1/storage/stores/integration/direct\` ## Response Returns an array of products with their IDs, slugs, names, supported protocols, and metadata requirements. Each product represents a different type of resource you can provision. The \`metadataSchema\` field contains a JSON Schema that defines: - **Required metadata**: Fields that must be provided during storage creation - **Optional metadata**: Fields that can be provided but are not mandatory - **Field validation**: Data types, allowed values, and constraints Use this schema to validate metadata before calling the storage creation endpoint.`,
  args,
  tool: async (client, args, ctx) => {
    const [result, apiCall] = await integrationsGetConfigurationProducts(
      client,
      args.request,
      { fetchOptions: { signal: ctx.signal } },
    ).$inspect();

    if (!result.ok) {
      return {
        content: [{ type: "text", text: result.error.message }],
        isError: true,
      };
    }

    const value = result.value;

    return formatResult(value, apiCall);
  },
};
