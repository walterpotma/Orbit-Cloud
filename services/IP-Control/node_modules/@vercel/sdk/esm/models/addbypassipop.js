/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
import * as z from "zod";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
export const ResponseBodyAction = {
    Block: "block",
    Bypass: "bypass",
};
/** @internal */
export const AddBypassIpRequestBody2$inboundSchema = z.object({
    domain: z.string().optional(),
    projectScope: z.boolean(),
    sourceIp: z.string().optional(),
    allSources: z.boolean().optional(),
    ttl: z.number().optional(),
    note: z.string().optional(),
});
/** @internal */
export const AddBypassIpRequestBody2$outboundSchema = z.object({
    domain: z.string().optional(),
    projectScope: z.boolean(),
    sourceIp: z.string().optional(),
    allSources: z.boolean().optional(),
    ttl: z.number().optional(),
    note: z.string().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var AddBypassIpRequestBody2$;
(function (AddBypassIpRequestBody2$) {
    /** @deprecated use `AddBypassIpRequestBody2$inboundSchema` instead. */
    AddBypassIpRequestBody2$.inboundSchema = AddBypassIpRequestBody2$inboundSchema;
    /** @deprecated use `AddBypassIpRequestBody2$outboundSchema` instead. */
    AddBypassIpRequestBody2$.outboundSchema = AddBypassIpRequestBody2$outboundSchema;
})(AddBypassIpRequestBody2$ || (AddBypassIpRequestBody2$ = {}));
export function addBypassIpRequestBody2ToJSON(addBypassIpRequestBody2) {
    return JSON.stringify(AddBypassIpRequestBody2$outboundSchema.parse(addBypassIpRequestBody2));
}
export function addBypassIpRequestBody2FromJSON(jsonString) {
    return safeParse(jsonString, (x) => AddBypassIpRequestBody2$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'AddBypassIpRequestBody2' from JSON`);
}
/** @internal */
export const AddBypassIpRequestBody1$inboundSchema = z.object({
    domain: z.string(),
    projectScope: z.boolean().optional(),
    sourceIp: z.string().optional(),
    allSources: z.boolean().optional(),
    ttl: z.number().optional(),
    note: z.string().optional(),
});
/** @internal */
export const AddBypassIpRequestBody1$outboundSchema = z.object({
    domain: z.string(),
    projectScope: z.boolean().optional(),
    sourceIp: z.string().optional(),
    allSources: z.boolean().optional(),
    ttl: z.number().optional(),
    note: z.string().optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var AddBypassIpRequestBody1$;
(function (AddBypassIpRequestBody1$) {
    /** @deprecated use `AddBypassIpRequestBody1$inboundSchema` instead. */
    AddBypassIpRequestBody1$.inboundSchema = AddBypassIpRequestBody1$inboundSchema;
    /** @deprecated use `AddBypassIpRequestBody1$outboundSchema` instead. */
    AddBypassIpRequestBody1$.outboundSchema = AddBypassIpRequestBody1$outboundSchema;
})(AddBypassIpRequestBody1$ || (AddBypassIpRequestBody1$ = {}));
export function addBypassIpRequestBody1ToJSON(addBypassIpRequestBody1) {
    return JSON.stringify(AddBypassIpRequestBody1$outboundSchema.parse(addBypassIpRequestBody1));
}
export function addBypassIpRequestBody1FromJSON(jsonString) {
    return safeParse(jsonString, (x) => AddBypassIpRequestBody1$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'AddBypassIpRequestBody1' from JSON`);
}
/** @internal */
export const AddBypassIpRequestBody$inboundSchema = z.union([
    z.lazy(() => AddBypassIpRequestBody1$inboundSchema),
    z.lazy(() => AddBypassIpRequestBody2$inboundSchema),
]);
/** @internal */
export const AddBypassIpRequestBody$outboundSchema = z.union([
    z.lazy(() => AddBypassIpRequestBody1$outboundSchema),
    z.lazy(() => AddBypassIpRequestBody2$outboundSchema),
]);
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var AddBypassIpRequestBody$;
(function (AddBypassIpRequestBody$) {
    /** @deprecated use `AddBypassIpRequestBody$inboundSchema` instead. */
    AddBypassIpRequestBody$.inboundSchema = AddBypassIpRequestBody$inboundSchema;
    /** @deprecated use `AddBypassIpRequestBody$outboundSchema` instead. */
    AddBypassIpRequestBody$.outboundSchema = AddBypassIpRequestBody$outboundSchema;
})(AddBypassIpRequestBody$ || (AddBypassIpRequestBody$ = {}));
export function addBypassIpRequestBodyToJSON(addBypassIpRequestBody) {
    return JSON.stringify(AddBypassIpRequestBody$outboundSchema.parse(addBypassIpRequestBody));
}
export function addBypassIpRequestBodyFromJSON(jsonString) {
    return safeParse(jsonString, (x) => AddBypassIpRequestBody$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'AddBypassIpRequestBody' from JSON`);
}
/** @internal */
export const AddBypassIpRequest$inboundSchema = z.object({
    projectId: z.string(),
    teamId: z.string().optional(),
    slug: z.string().optional(),
    RequestBody: z.union([
        z.lazy(() => AddBypassIpRequestBody1$inboundSchema),
        z.lazy(() => AddBypassIpRequestBody2$inboundSchema),
    ]).optional(),
}).transform((v) => {
    return remap$(v, {
        "RequestBody": "requestBody",
    });
});
/** @internal */
export const AddBypassIpRequest$outboundSchema = z.object({
    projectId: z.string(),
    teamId: z.string().optional(),
    slug: z.string().optional(),
    requestBody: z.union([
        z.lazy(() => AddBypassIpRequestBody1$outboundSchema),
        z.lazy(() => AddBypassIpRequestBody2$outboundSchema),
    ]).optional(),
}).transform((v) => {
    return remap$(v, {
        requestBody: "RequestBody",
    });
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var AddBypassIpRequest$;
(function (AddBypassIpRequest$) {
    /** @deprecated use `AddBypassIpRequest$inboundSchema` instead. */
    AddBypassIpRequest$.inboundSchema = AddBypassIpRequest$inboundSchema;
    /** @deprecated use `AddBypassIpRequest$outboundSchema` instead. */
    AddBypassIpRequest$.outboundSchema = AddBypassIpRequest$outboundSchema;
})(AddBypassIpRequest$ || (AddBypassIpRequest$ = {}));
export function addBypassIpRequestToJSON(addBypassIpRequest) {
    return JSON.stringify(AddBypassIpRequest$outboundSchema.parse(addBypassIpRequest));
}
export function addBypassIpRequestFromJSON(jsonString) {
    return safeParse(jsonString, (x) => AddBypassIpRequest$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'AddBypassIpRequest' from JSON`);
}
/** @internal */
export const ResponseBodyAction$inboundSchema = z.nativeEnum(ResponseBodyAction);
/** @internal */
export const ResponseBodyAction$outboundSchema = ResponseBodyAction$inboundSchema;
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var ResponseBodyAction$;
(function (ResponseBodyAction$) {
    /** @deprecated use `ResponseBodyAction$inboundSchema` instead. */
    ResponseBodyAction$.inboundSchema = ResponseBodyAction$inboundSchema;
    /** @deprecated use `ResponseBodyAction$outboundSchema` instead. */
    ResponseBodyAction$.outboundSchema = ResponseBodyAction$outboundSchema;
})(ResponseBodyAction$ || (ResponseBodyAction$ = {}));
/** @internal */
export const AddBypassIpResponseBodyResult$inboundSchema = z.object({
    OwnerId: z.string(),
    Id: z.string(),
    Domain: z.string(),
    Ip: z.string(),
    Action: ResponseBodyAction$inboundSchema.optional(),
    ProjectId: z.string().optional(),
    IsProjectRule: z.boolean().optional(),
    Note: z.string().optional(),
    CreatedAt: z.string(),
    ActorId: z.string().optional(),
    UpdatedAt: z.string(),
    UpdatedAtHour: z.string(),
    DeletedAt: z.string().optional(),
    ExpiresAt: z.nullable(z.number()).optional(),
}).transform((v) => {
    return remap$(v, {
        "OwnerId": "ownerId",
        "Id": "id",
        "Domain": "domain",
        "Ip": "ip",
        "Action": "action",
        "ProjectId": "projectId",
        "IsProjectRule": "isProjectRule",
        "Note": "note",
        "CreatedAt": "createdAt",
        "ActorId": "actorId",
        "UpdatedAt": "updatedAt",
        "UpdatedAtHour": "updatedAtHour",
        "DeletedAt": "deletedAt",
        "ExpiresAt": "expiresAt",
    });
});
/** @internal */
export const AddBypassIpResponseBodyResult$outboundSchema = z.object({
    ownerId: z.string(),
    id: z.string(),
    domain: z.string(),
    ip: z.string(),
    action: ResponseBodyAction$outboundSchema.optional(),
    projectId: z.string().optional(),
    isProjectRule: z.boolean().optional(),
    note: z.string().optional(),
    createdAt: z.string(),
    actorId: z.string().optional(),
    updatedAt: z.string(),
    updatedAtHour: z.string(),
    deletedAt: z.string().optional(),
    expiresAt: z.nullable(z.number()).optional(),
}).transform((v) => {
    return remap$(v, {
        ownerId: "OwnerId",
        id: "Id",
        domain: "Domain",
        ip: "Ip",
        action: "Action",
        projectId: "ProjectId",
        isProjectRule: "IsProjectRule",
        note: "Note",
        createdAt: "CreatedAt",
        actorId: "ActorId",
        updatedAt: "UpdatedAt",
        updatedAtHour: "UpdatedAtHour",
        deletedAt: "DeletedAt",
        expiresAt: "ExpiresAt",
    });
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var AddBypassIpResponseBodyResult$;
(function (AddBypassIpResponseBodyResult$) {
    /** @deprecated use `AddBypassIpResponseBodyResult$inboundSchema` instead. */
    AddBypassIpResponseBodyResult$.inboundSchema = AddBypassIpResponseBodyResult$inboundSchema;
    /** @deprecated use `AddBypassIpResponseBodyResult$outboundSchema` instead. */
    AddBypassIpResponseBodyResult$.outboundSchema = AddBypassIpResponseBodyResult$outboundSchema;
})(AddBypassIpResponseBodyResult$ || (AddBypassIpResponseBodyResult$ = {}));
export function addBypassIpResponseBodyResultToJSON(addBypassIpResponseBodyResult) {
    return JSON.stringify(AddBypassIpResponseBodyResult$outboundSchema.parse(addBypassIpResponseBodyResult));
}
export function addBypassIpResponseBodyResultFromJSON(jsonString) {
    return safeParse(jsonString, (x) => AddBypassIpResponseBodyResult$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'AddBypassIpResponseBodyResult' from JSON`);
}
/** @internal */
export const AddBypassIpResponseBody2$inboundSchema = z.object({
    ok: z.boolean(),
    result: z.array(z.lazy(() => AddBypassIpResponseBodyResult$inboundSchema))
        .optional(),
});
/** @internal */
export const AddBypassIpResponseBody2$outboundSchema = z.object({
    ok: z.boolean(),
    result: z.array(z.lazy(() => AddBypassIpResponseBodyResult$outboundSchema))
        .optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var AddBypassIpResponseBody2$;
(function (AddBypassIpResponseBody2$) {
    /** @deprecated use `AddBypassIpResponseBody2$inboundSchema` instead. */
    AddBypassIpResponseBody2$.inboundSchema = AddBypassIpResponseBody2$inboundSchema;
    /** @deprecated use `AddBypassIpResponseBody2$outboundSchema` instead. */
    AddBypassIpResponseBody2$.outboundSchema = AddBypassIpResponseBody2$outboundSchema;
})(AddBypassIpResponseBody2$ || (AddBypassIpResponseBody2$ = {}));
export function addBypassIpResponseBody2ToJSON(addBypassIpResponseBody2) {
    return JSON.stringify(AddBypassIpResponseBody2$outboundSchema.parse(addBypassIpResponseBody2));
}
export function addBypassIpResponseBody2FromJSON(jsonString) {
    return safeParse(jsonString, (x) => AddBypassIpResponseBody2$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'AddBypassIpResponseBody2' from JSON`);
}
/** @internal */
export const ResponseBodyResult$inboundSchema = z.object({
    OwnerId: z.string(),
    Id: z.string(),
    Domain: z.string(),
    Ip: z.string().optional(),
    ProjectId: z.string(),
    Note: z.string(),
    IsProjectRule: z.boolean(),
}).transform((v) => {
    return remap$(v, {
        "OwnerId": "ownerId",
        "Id": "id",
        "Domain": "domain",
        "Ip": "ip",
        "ProjectId": "projectId",
        "Note": "note",
        "IsProjectRule": "isProjectRule",
    });
});
/** @internal */
export const ResponseBodyResult$outboundSchema = z.object({
    ownerId: z.string(),
    id: z.string(),
    domain: z.string(),
    ip: z.string().optional(),
    projectId: z.string(),
    note: z.string(),
    isProjectRule: z.boolean(),
}).transform((v) => {
    return remap$(v, {
        ownerId: "OwnerId",
        id: "Id",
        domain: "Domain",
        ip: "Ip",
        projectId: "ProjectId",
        note: "Note",
        isProjectRule: "IsProjectRule",
    });
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var ResponseBodyResult$;
(function (ResponseBodyResult$) {
    /** @deprecated use `ResponseBodyResult$inboundSchema` instead. */
    ResponseBodyResult$.inboundSchema = ResponseBodyResult$inboundSchema;
    /** @deprecated use `ResponseBodyResult$outboundSchema` instead. */
    ResponseBodyResult$.outboundSchema = ResponseBodyResult$outboundSchema;
})(ResponseBodyResult$ || (ResponseBodyResult$ = {}));
export function responseBodyResultToJSON(responseBodyResult) {
    return JSON.stringify(ResponseBodyResult$outboundSchema.parse(responseBodyResult));
}
export function responseBodyResultFromJSON(jsonString) {
    return safeParse(jsonString, (x) => ResponseBodyResult$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'ResponseBodyResult' from JSON`);
}
/** @internal */
export const AddBypassIpResponseBody1$inboundSchema = z.object({
    ok: z.boolean(),
    result: z.array(z.lazy(() => ResponseBodyResult$inboundSchema)),
    pagination: z.nullable(z.any()).optional(),
});
/** @internal */
export const AddBypassIpResponseBody1$outboundSchema = z.object({
    ok: z.boolean(),
    result: z.array(z.lazy(() => ResponseBodyResult$outboundSchema)),
    pagination: z.nullable(z.any()).optional(),
});
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var AddBypassIpResponseBody1$;
(function (AddBypassIpResponseBody1$) {
    /** @deprecated use `AddBypassIpResponseBody1$inboundSchema` instead. */
    AddBypassIpResponseBody1$.inboundSchema = AddBypassIpResponseBody1$inboundSchema;
    /** @deprecated use `AddBypassIpResponseBody1$outboundSchema` instead. */
    AddBypassIpResponseBody1$.outboundSchema = AddBypassIpResponseBody1$outboundSchema;
})(AddBypassIpResponseBody1$ || (AddBypassIpResponseBody1$ = {}));
export function addBypassIpResponseBody1ToJSON(addBypassIpResponseBody1) {
    return JSON.stringify(AddBypassIpResponseBody1$outboundSchema.parse(addBypassIpResponseBody1));
}
export function addBypassIpResponseBody1FromJSON(jsonString) {
    return safeParse(jsonString, (x) => AddBypassIpResponseBody1$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'AddBypassIpResponseBody1' from JSON`);
}
/** @internal */
export const AddBypassIpResponseBody$inboundSchema = z.union([
    z.lazy(() => AddBypassIpResponseBody1$inboundSchema),
    z.lazy(() => AddBypassIpResponseBody2$inboundSchema),
]);
/** @internal */
export const AddBypassIpResponseBody$outboundSchema = z.union([
    z.lazy(() => AddBypassIpResponseBody1$outboundSchema),
    z.lazy(() => AddBypassIpResponseBody2$outboundSchema),
]);
/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export var AddBypassIpResponseBody$;
(function (AddBypassIpResponseBody$) {
    /** @deprecated use `AddBypassIpResponseBody$inboundSchema` instead. */
    AddBypassIpResponseBody$.inboundSchema = AddBypassIpResponseBody$inboundSchema;
    /** @deprecated use `AddBypassIpResponseBody$outboundSchema` instead. */
    AddBypassIpResponseBody$.outboundSchema = AddBypassIpResponseBody$outboundSchema;
})(AddBypassIpResponseBody$ || (AddBypassIpResponseBody$ = {}));
export function addBypassIpResponseBodyToJSON(addBypassIpResponseBody) {
    return JSON.stringify(AddBypassIpResponseBody$outboundSchema.parse(addBypassIpResponseBody));
}
export function addBypassIpResponseBodyFromJSON(jsonString) {
    return safeParse(jsonString, (x) => AddBypassIpResponseBody$inboundSchema.parse(JSON.parse(x)), `Failed to parse 'AddBypassIpResponseBody' from JSON`);
}
//# sourceMappingURL=addbypassipop.js.map