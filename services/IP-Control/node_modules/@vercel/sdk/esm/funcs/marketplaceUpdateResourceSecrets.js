/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
import * as z from "zod";
import { encodeJSON, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import { UpdateResourceSecretsRequest$outboundSchema, } from "../models/updateresourcesecretsop.js";
import { VercelBadRequestError$inboundSchema, } from "../models/vercelbadrequesterror.js";
import { VercelForbiddenError$inboundSchema, } from "../models/vercelforbiddenerror.js";
import { VercelNotFoundError$inboundSchema, } from "../models/vercelnotfounderror.js";
import { APIPromise } from "../types/async.js";
/**
 * Update Resource Secrets (Deprecated)
 *
 * @remarks
 * This endpoint is deprecated and replaced with the endpoint [Update Resource Secrets](#update-resource-secrets). <br/> This endpoint updates the secrets of a resource. If a resource has projects connected, the connected secrets are updated with the new secrets. The old secrets may still be used by existing connected projects because they are not automatically redeployed. Redeployment is a manual action and must be completed by the user. All new project connections will use the new secrets.<br/> <br/> Use cases for this endpoint:<br/> <br/> - Resetting the credentials of a database in the partner. If the user requests the credentials to be updated in the partnerâ€™s application, the partner post the new set of secrets to Vercel, the user should redeploy their application and the expire the old credentials.<br/>
 */
export function marketplaceUpdateResourceSecrets(client, request, options) {
    return new APIPromise($do(client, request, options));
}
async function $do(client, request, options) {
    const parsed = safeParse(request, (value) => UpdateResourceSecretsRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload.RequestBody, { explode: true });
    const pathParams = {
        integrationConfigurationId: encodeSimple("integrationConfigurationId", payload.integrationConfigurationId, { explode: false, charEncoding: "percent" }),
        integrationProductIdOrSlug: encodeSimple("integrationProductIdOrSlug", payload.integrationProductIdOrSlug, { explode: false, charEncoding: "percent" }),
        resourceId: encodeSimple("resourceId", payload.resourceId, {
            explode: false,
            charEncoding: "percent",
        }),
    };
    const path = pathToFunc("/v1/installations/{integrationConfigurationId}/products/{integrationProductIdOrSlug}/resources/{resourceId}/secrets")(pathParams);
    const headers = new Headers(compactMap({
        "Content-Type": "application/json",
        Accept: "application/json",
    }));
    const secConfig = await extractSecurity(client._options.bearerToken);
    const securityInput = secConfig == null ? {} : { bearerToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
        options: client._options,
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "update-resource-secrets",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.bearerToken,
        retryConfig: options?.retries
            || client._options.retryConfig
            || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
    };
    const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "PUT",
        baseURL: options?.serverURL,
        path: path,
        headers: headers,
        body: body,
        userAgent: client._options.userAgent,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
    }, options);
    if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
        context,
        errorCodes: ["400", "401", "403", "404", "4XX", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes,
    });
    if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const responseFields = {
        HttpMeta: { Response: response, Request: req },
    };
    const [result] = await M.match(M.nil(201, z.void()), M.jsonErr(400, VercelBadRequestError$inboundSchema), M.jsonErr(401, VercelForbiddenError$inboundSchema), M.jsonErr(404, VercelNotFoundError$inboundSchema), M.fail([403, "4XX"]), M.fail("5XX"))(response, req, { extraFields: responseFields });
    if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
}
//# sourceMappingURL=marketplaceUpdateResourceSecrets.js.map