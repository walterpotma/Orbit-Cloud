ğŸ—ºï¸ Roadmap: Rumo Ã  Orbit v0.2.0
1. ğŸ§¹ RefatoraÃ§Ã£o: Shell Scripts â¡ï¸ C# Nativo (Prioridade Alta)
Atualmente, depender de arquivos .sh (clone.sh, build.sh) Ã© frÃ¡gil. Se o servidor mudar, se as permissÃµes de arquivo mudarem ou se der um erro no meio do script, sua API nÃ£o fica sabendo direito.

O Plano: Substituir chamadas de terminal soltas por cÃ³digo gerenciado.

Como:

Git Clone: Usar a biblioteca CliWrap para rodar o git clone de forma controlada ou LibGit2Sharp.

Docker Build: Usar a Docker.DotNet (que vocÃª jÃ¡ adicionou) para comandar o build direto no socket do Docker, ou CliWrap para rodar docker build capturando o output linha a linha.

K8s Apply: Parar de usar arquivos YAML temporÃ¡rios no disco. Criar os objetos (V1Deployment, V1Service) instanciados direto no C# e mandar pro cluster via KubernetesClient.

Ganho: VocÃª elimina a "sujeira" de arquivos temporÃ¡rios e consegue pegar try/catch de verdade se o build falhar.

2. ğŸ—‘ï¸ Implementar o DELETE (Faxina Completa)
Para testar Ã  vontade, vocÃª precisa conseguir apagar o que criou.

O Desafio: NÃ£o Ã© sÃ³ apagar do banco de dados (SQL).

O Fluxo Correto:

Recebe ID do Deploy.

Busca no Banco para pegar o GithubID (Namespace) e RepoName.

K8s: Deleta o Deployment.

K8s: Deleta o Service.

K8s: Deleta o Ingress (Isso automaticamente remove a rota do Cloudflare Tunnel se estiver configurado certo).

SQL: Deleta (ou marca como DeletedAt) o registro no banco.

3. ğŸ”„ Implementar o UPDATE (Redeploy)
O usuÃ¡rio mudou o cÃ³digo no GitHub e quer atualizar o site.

O Fluxo: Ã‰ basicamente repetir o processo de Create, mas garantindo que vocÃª nÃ£o crie conflito de nomes.

EstratÃ©gia:

Gerar uma nova tag de versÃ£o (ex: v2, v3 ou Timestamp).

Fazer o Build.

Atualizar a imagem no Deployment existente no K8s.

O K8s faz o "Rolling Update" (sobe o novo, espera ficar saudÃ¡vel, mata o velho) sozinho.

4. ğŸ’… UX e Feedback (Polimento)
Melhorar as mensagens de erro.

Se o token do GitHub expirou, avisar o usuÃ¡rio.

Se o nome do projeto Ã© invÃ¡lido (tem espaÃ§o ou acento), bloquear antes de tentar enviar.

5. ğŸ‡ A Grande MigraÃ§Ã£o: Async com RabbitMQ
SÃ“ DEPOIS de tudo acima estar limpo e testado em cÃ³digo sÃ­ncrono (travando a tela mesmo), a gente move a lÃ³gica para o Worker.

Ã‰ muito mais fÃ¡cil mover um cÃ³digo C# limpo ("Classe BuildService") para o Worker do que mover um monte de script .sh gambiarra.

Qual o primeiro passo?
Eu recomendo fortemente comeÃ§ar pelo Item 1 (Tirar os Scripts .sh).

Por quÃª? Porque isso vai "sanear" o nÃºcleo da sua aplicaÃ§Ã£o. Quando vocÃª for fazer o Worker (RabbitMQ), vai ser sÃ³ copiar e colar mÃ©todos C# limpos, em vez de ficar brigando com script bash em background.

Quer comeÃ§ar matando qual script primeiro? O de Clone ou o de Deploy/YAML? ğŸ› ï¸