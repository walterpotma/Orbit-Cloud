/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
import * as z from "zod";
import { encodeFormQuery, encodeJSON, encodeSimple } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import { PatchUrlProtectionBypassRequest$outboundSchema, } from "../models/patchurlprotectionbypassop.js";
import { VercelBadRequestError$inboundSchema, } from "../models/vercelbadrequesterror.js";
import { VercelForbiddenError$inboundSchema, } from "../models/vercelforbiddenerror.js";
import { VercelNotFoundError$inboundSchema, } from "../models/vercelnotfounderror.js";
import { APIPromise } from "../types/async.js";
/**
 * Update the protection bypass for a URL
 *
 * @remarks
 * Update the protection bypass for the alias or deployment URL (used for user access & comment access for deployments). Used as shareable links and user scoped access for Vercel Authentication and also to allow external (logged in) people to comment on previews for Preview Comments (next-live-mode).
 */
export function aliasesPatchUrlProtectionBypass(client, request, options) {
    return new APIPromise($do(client, request, options));
}
async function $do(client, request, options) {
    const parsed = safeParse(request, (value) => PatchUrlProtectionBypassRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
        return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload.RequestBody, { explode: true });
    const pathParams = {
        id: encodeSimple("id", payload.id, {
            explode: false,
            charEncoding: "percent",
        }),
    };
    const path = pathToFunc("/aliases/{id}/protection-bypass")(pathParams);
    const query = encodeFormQuery({
        "slug": payload.slug,
        "teamId": payload.teamId,
    });
    const headers = new Headers(compactMap({
        "Content-Type": "application/json",
        Accept: "application/json",
    }));
    const secConfig = await extractSecurity(client._options.bearerToken);
    const securityInput = secConfig == null ? {} : { bearerToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
        options: client._options,
        baseURL: options?.serverURL ?? client._baseURL ?? "",
        operationID: "patchUrlProtectionBypass",
        oAuth2Scopes: [],
        resolvedSecurity: requestSecurity,
        securitySource: client._options.bearerToken,
        retryConfig: options?.retries
            || client._options.retryConfig
            || { strategy: "none" },
        retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
    };
    const requestRes = client._createRequest(context, {
        security: requestSecurity,
        method: "PATCH",
        baseURL: options?.serverURL,
        path: path,
        headers: headers,
        query: query,
        body: body,
        userAgent: client._options.userAgent,
        timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
    }, options);
    if (!requestRes.ok) {
        return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
        context,
        errorCodes: ["400", "401", "403", "404", "409", "428", "4XX", "500", "5XX"],
        retryConfig: context.retryConfig,
        retryCodes: context.retryCodes,
    });
    if (!doResult.ok) {
        return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const responseFields = {
        HttpMeta: { Response: response, Request: req },
    };
    const [result] = await M.match(M.json(200, z.record(z.any())), M.jsonErr(400, VercelBadRequestError$inboundSchema), M.jsonErr(401, VercelForbiddenError$inboundSchema), M.jsonErr(404, VercelNotFoundError$inboundSchema), M.fail([403, 409, 428, "4XX"]), M.fail([500, "5XX"]))(response, req, { extraFields: responseFields });
    if (!result.ok) {
        return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
}
//# sourceMappingURL=aliasesPatchUrlProtectionBypass.js.map