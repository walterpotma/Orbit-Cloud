/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./sdkvalidationerror.js";

/**
 * When true, the response will only include the nameservers assigned directly to the specified domain. When false and there are no nameservers assigned directly to the specified domain, the response will include the nameservers of the domain's parent zone.
 */
export const Strict = {
  True: "true",
  False: "false",
} as const;
/**
 * When true, the response will only include the nameservers assigned directly to the specified domain. When false and there are no nameservers assigned directly to the specified domain, the response will include the nameservers of the domain's parent zone.
 */
export type Strict = ClosedEnum<typeof Strict>;

export type GetDomainConfigRequest = {
  /**
   * The name of the domain.
   */
  domain: string;
  /**
   * The project id or name that will be associated with the domain. Use this when the domain is not yet associated with a project.
   */
  projectIdOrName?: string | undefined;
  /**
   * When true, the response will only include the nameservers assigned directly to the specified domain. When false and there are no nameservers assigned directly to the specified domain, the response will include the nameservers of the domain's parent zone.
   */
  strict?: Strict | undefined;
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string | undefined;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string | undefined;
};

/**
 * How we see the domain's configuration. - `CNAME`: Domain has a CNAME pointing to Vercel. - `A`: Domain's A record is resolving to Vercel. - `http`: Domain is resolving to Vercel but may be behind a Proxy. - `dns-01`: Domain is not resolving to Vercel but dns-01 challenge is enabled. - `null`: Domain is not resolving to Vercel.
 */
export const ConfiguredBy = {
  Cname: "CNAME",
  A: "A",
  Http: "http",
  Dns01: "dns-01",
} as const;
/**
 * How we see the domain's configuration. - `CNAME`: Domain has a CNAME pointing to Vercel. - `A`: Domain's A record is resolving to Vercel. - `http`: Domain is resolving to Vercel but may be behind a Proxy. - `dns-01`: Domain is not resolving to Vercel but dns-01 challenge is enabled. - `null`: Domain is not resolving to Vercel.
 */
export type ConfiguredBy = ClosedEnum<typeof ConfiguredBy>;

/**
 * Which challenge types the domain can use for issuing certs.
 */
export const AcceptedChallenges = {
  Dns01: "dns-01",
  Http01: "http-01",
} as const;
/**
 * Which challenge types the domain can use for issuing certs.
 */
export type AcceptedChallenges = ClosedEnum<typeof AcceptedChallenges>;

/**
 * Recommended IPv4s for the domain. rank=1 is the preferred value(s) to use. Only using 1 ip value is acceptable.
 */
export type RecommendedIPv4 = {
  rank: number;
  value: Array<string>;
};

/**
 * Recommended CNAMEs for the domain. rank=1 is the preferred value to use.
 */
export type RecommendedCNAME = {
  rank: number;
  value: string;
};

export type GetDomainConfigResponseBody = {
  /**
   * How we see the domain's configuration. - `CNAME`: Domain has a CNAME pointing to Vercel. - `A`: Domain's A record is resolving to Vercel. - `http`: Domain is resolving to Vercel but may be behind a Proxy. - `dns-01`: Domain is not resolving to Vercel but dns-01 challenge is enabled. - `null`: Domain is not resolving to Vercel.
   */
  configuredBy: ConfiguredBy | null;
  /**
   * Which challenge types the domain can use for issuing certs.
   */
  acceptedChallenges: Array<AcceptedChallenges>;
  /**
   * Recommended IPv4s for the domain. rank=1 is the preferred value(s) to use. Only using 1 ip value is acceptable.
   */
  recommendedIPv4: Array<RecommendedIPv4>;
  /**
   * Recommended CNAMEs for the domain. rank=1 is the preferred value to use.
   */
  recommendedCNAME: Array<RecommendedCNAME>;
  /**
   * Whether or not the domain is configured AND we can automatically generate a TLS certificate.
   */
  misconfigured: boolean;
};

/** @internal */
export const Strict$inboundSchema: z.ZodNativeEnum<typeof Strict> = z
  .nativeEnum(Strict);

/** @internal */
export const Strict$outboundSchema: z.ZodNativeEnum<typeof Strict> =
  Strict$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Strict$ {
  /** @deprecated use `Strict$inboundSchema` instead. */
  export const inboundSchema = Strict$inboundSchema;
  /** @deprecated use `Strict$outboundSchema` instead. */
  export const outboundSchema = Strict$outboundSchema;
}

/** @internal */
export const GetDomainConfigRequest$inboundSchema: z.ZodType<
  GetDomainConfigRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  domain: z.string(),
  projectIdOrName: z.string().optional(),
  strict: Strict$inboundSchema.optional(),
  teamId: z.string().optional(),
  slug: z.string().optional(),
});

/** @internal */
export type GetDomainConfigRequest$Outbound = {
  domain: string;
  projectIdOrName?: string | undefined;
  strict?: string | undefined;
  teamId?: string | undefined;
  slug?: string | undefined;
};

/** @internal */
export const GetDomainConfigRequest$outboundSchema: z.ZodType<
  GetDomainConfigRequest$Outbound,
  z.ZodTypeDef,
  GetDomainConfigRequest
> = z.object({
  domain: z.string(),
  projectIdOrName: z.string().optional(),
  strict: Strict$outboundSchema.optional(),
  teamId: z.string().optional(),
  slug: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetDomainConfigRequest$ {
  /** @deprecated use `GetDomainConfigRequest$inboundSchema` instead. */
  export const inboundSchema = GetDomainConfigRequest$inboundSchema;
  /** @deprecated use `GetDomainConfigRequest$outboundSchema` instead. */
  export const outboundSchema = GetDomainConfigRequest$outboundSchema;
  /** @deprecated use `GetDomainConfigRequest$Outbound` instead. */
  export type Outbound = GetDomainConfigRequest$Outbound;
}

export function getDomainConfigRequestToJSON(
  getDomainConfigRequest: GetDomainConfigRequest,
): string {
  return JSON.stringify(
    GetDomainConfigRequest$outboundSchema.parse(getDomainConfigRequest),
  );
}

export function getDomainConfigRequestFromJSON(
  jsonString: string,
): SafeParseResult<GetDomainConfigRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetDomainConfigRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetDomainConfigRequest' from JSON`,
  );
}

/** @internal */
export const ConfiguredBy$inboundSchema: z.ZodNativeEnum<typeof ConfiguredBy> =
  z.nativeEnum(ConfiguredBy);

/** @internal */
export const ConfiguredBy$outboundSchema: z.ZodNativeEnum<typeof ConfiguredBy> =
  ConfiguredBy$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConfiguredBy$ {
  /** @deprecated use `ConfiguredBy$inboundSchema` instead. */
  export const inboundSchema = ConfiguredBy$inboundSchema;
  /** @deprecated use `ConfiguredBy$outboundSchema` instead. */
  export const outboundSchema = ConfiguredBy$outboundSchema;
}

/** @internal */
export const AcceptedChallenges$inboundSchema: z.ZodNativeEnum<
  typeof AcceptedChallenges
> = z.nativeEnum(AcceptedChallenges);

/** @internal */
export const AcceptedChallenges$outboundSchema: z.ZodNativeEnum<
  typeof AcceptedChallenges
> = AcceptedChallenges$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AcceptedChallenges$ {
  /** @deprecated use `AcceptedChallenges$inboundSchema` instead. */
  export const inboundSchema = AcceptedChallenges$inboundSchema;
  /** @deprecated use `AcceptedChallenges$outboundSchema` instead. */
  export const outboundSchema = AcceptedChallenges$outboundSchema;
}

/** @internal */
export const RecommendedIPv4$inboundSchema: z.ZodType<
  RecommendedIPv4,
  z.ZodTypeDef,
  unknown
> = z.object({
  rank: z.number(),
  value: z.array(z.string()),
});

/** @internal */
export type RecommendedIPv4$Outbound = {
  rank: number;
  value: Array<string>;
};

/** @internal */
export const RecommendedIPv4$outboundSchema: z.ZodType<
  RecommendedIPv4$Outbound,
  z.ZodTypeDef,
  RecommendedIPv4
> = z.object({
  rank: z.number(),
  value: z.array(z.string()),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RecommendedIPv4$ {
  /** @deprecated use `RecommendedIPv4$inboundSchema` instead. */
  export const inboundSchema = RecommendedIPv4$inboundSchema;
  /** @deprecated use `RecommendedIPv4$outboundSchema` instead. */
  export const outboundSchema = RecommendedIPv4$outboundSchema;
  /** @deprecated use `RecommendedIPv4$Outbound` instead. */
  export type Outbound = RecommendedIPv4$Outbound;
}

export function recommendedIPv4ToJSON(
  recommendedIPv4: RecommendedIPv4,
): string {
  return JSON.stringify(RecommendedIPv4$outboundSchema.parse(recommendedIPv4));
}

export function recommendedIPv4FromJSON(
  jsonString: string,
): SafeParseResult<RecommendedIPv4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RecommendedIPv4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RecommendedIPv4' from JSON`,
  );
}

/** @internal */
export const RecommendedCNAME$inboundSchema: z.ZodType<
  RecommendedCNAME,
  z.ZodTypeDef,
  unknown
> = z.object({
  rank: z.number(),
  value: z.string(),
});

/** @internal */
export type RecommendedCNAME$Outbound = {
  rank: number;
  value: string;
};

/** @internal */
export const RecommendedCNAME$outboundSchema: z.ZodType<
  RecommendedCNAME$Outbound,
  z.ZodTypeDef,
  RecommendedCNAME
> = z.object({
  rank: z.number(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RecommendedCNAME$ {
  /** @deprecated use `RecommendedCNAME$inboundSchema` instead. */
  export const inboundSchema = RecommendedCNAME$inboundSchema;
  /** @deprecated use `RecommendedCNAME$outboundSchema` instead. */
  export const outboundSchema = RecommendedCNAME$outboundSchema;
  /** @deprecated use `RecommendedCNAME$Outbound` instead. */
  export type Outbound = RecommendedCNAME$Outbound;
}

export function recommendedCNAMEToJSON(
  recommendedCNAME: RecommendedCNAME,
): string {
  return JSON.stringify(
    RecommendedCNAME$outboundSchema.parse(recommendedCNAME),
  );
}

export function recommendedCNAMEFromJSON(
  jsonString: string,
): SafeParseResult<RecommendedCNAME, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RecommendedCNAME$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RecommendedCNAME' from JSON`,
  );
}

/** @internal */
export const GetDomainConfigResponseBody$inboundSchema: z.ZodType<
  GetDomainConfigResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  configuredBy: z.nullable(ConfiguredBy$inboundSchema),
  acceptedChallenges: z.array(AcceptedChallenges$inboundSchema),
  recommendedIPv4: z.array(z.lazy(() => RecommendedIPv4$inboundSchema)),
  recommendedCNAME: z.array(z.lazy(() => RecommendedCNAME$inboundSchema)),
  misconfigured: z.boolean(),
});

/** @internal */
export type GetDomainConfigResponseBody$Outbound = {
  configuredBy: string | null;
  acceptedChallenges: Array<string>;
  recommendedIPv4: Array<RecommendedIPv4$Outbound>;
  recommendedCNAME: Array<RecommendedCNAME$Outbound>;
  misconfigured: boolean;
};

/** @internal */
export const GetDomainConfigResponseBody$outboundSchema: z.ZodType<
  GetDomainConfigResponseBody$Outbound,
  z.ZodTypeDef,
  GetDomainConfigResponseBody
> = z.object({
  configuredBy: z.nullable(ConfiguredBy$outboundSchema),
  acceptedChallenges: z.array(AcceptedChallenges$outboundSchema),
  recommendedIPv4: z.array(z.lazy(() => RecommendedIPv4$outboundSchema)),
  recommendedCNAME: z.array(z.lazy(() => RecommendedCNAME$outboundSchema)),
  misconfigured: z.boolean(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetDomainConfigResponseBody$ {
  /** @deprecated use `GetDomainConfigResponseBody$inboundSchema` instead. */
  export const inboundSchema = GetDomainConfigResponseBody$inboundSchema;
  /** @deprecated use `GetDomainConfigResponseBody$outboundSchema` instead. */
  export const outboundSchema = GetDomainConfigResponseBody$outboundSchema;
  /** @deprecated use `GetDomainConfigResponseBody$Outbound` instead. */
  export type Outbound = GetDomainConfigResponseBody$Outbound;
}

export function getDomainConfigResponseBodyToJSON(
  getDomainConfigResponseBody: GetDomainConfigResponseBody,
): string {
  return JSON.stringify(
    GetDomainConfigResponseBody$outboundSchema.parse(
      getDomainConfigResponseBody,
    ),
  );
}

export function getDomainConfigResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<GetDomainConfigResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetDomainConfigResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetDomainConfigResponseBody' from JSON`,
  );
}
