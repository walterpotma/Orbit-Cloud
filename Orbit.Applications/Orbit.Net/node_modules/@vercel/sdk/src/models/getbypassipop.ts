/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./sdkvalidationerror.js";

export type GetBypassIpRequest = {
  projectId: string;
  limit?: number | undefined;
  /**
   * Filter by source IP
   */
  sourceIp?: string | undefined;
  /**
   * Filter by domain
   */
  domain?: string | undefined;
  /**
   * Filter by project scoped rules
   */
  projectScope?: boolean | undefined;
  /**
   * Used for pagination. Retrieves results after the provided id
   */
  offset?: string | undefined;
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string | undefined;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string | undefined;
};

export const GetBypassIpAction = {
  Block: "block",
  Bypass: "bypass",
} as const;
export type GetBypassIpAction = ClosedEnum<typeof GetBypassIpAction>;

export type GetBypassIpResult = {
  ownerId: string;
  id: string;
  domain: string;
  ip: string;
  action?: GetBypassIpAction | undefined;
  projectId?: string | undefined;
  isProjectRule?: boolean | undefined;
  note?: string | undefined;
  createdAt: string;
  actorId?: string | undefined;
  updatedAt: string;
  updatedAtHour: string;
  deletedAt?: string | undefined;
  expiresAt?: number | null | undefined;
};

export type GetBypassIpPagination = {
  ownerId: string;
  id: string;
};

export type GetBypassIpResponseBody = {
  result: Array<GetBypassIpResult>;
  pagination?: GetBypassIpPagination | undefined;
};

/** @internal */
export const GetBypassIpRequest$inboundSchema: z.ZodType<
  GetBypassIpRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  projectId: z.string(),
  limit: z.number().optional(),
  sourceIp: z.string().optional(),
  domain: z.string().optional(),
  projectScope: z.boolean().optional(),
  offset: z.string().optional(),
  teamId: z.string().optional(),
  slug: z.string().optional(),
});

/** @internal */
export type GetBypassIpRequest$Outbound = {
  projectId: string;
  limit?: number | undefined;
  sourceIp?: string | undefined;
  domain?: string | undefined;
  projectScope?: boolean | undefined;
  offset?: string | undefined;
  teamId?: string | undefined;
  slug?: string | undefined;
};

/** @internal */
export const GetBypassIpRequest$outboundSchema: z.ZodType<
  GetBypassIpRequest$Outbound,
  z.ZodTypeDef,
  GetBypassIpRequest
> = z.object({
  projectId: z.string(),
  limit: z.number().optional(),
  sourceIp: z.string().optional(),
  domain: z.string().optional(),
  projectScope: z.boolean().optional(),
  offset: z.string().optional(),
  teamId: z.string().optional(),
  slug: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetBypassIpRequest$ {
  /** @deprecated use `GetBypassIpRequest$inboundSchema` instead. */
  export const inboundSchema = GetBypassIpRequest$inboundSchema;
  /** @deprecated use `GetBypassIpRequest$outboundSchema` instead. */
  export const outboundSchema = GetBypassIpRequest$outboundSchema;
  /** @deprecated use `GetBypassIpRequest$Outbound` instead. */
  export type Outbound = GetBypassIpRequest$Outbound;
}

export function getBypassIpRequestToJSON(
  getBypassIpRequest: GetBypassIpRequest,
): string {
  return JSON.stringify(
    GetBypassIpRequest$outboundSchema.parse(getBypassIpRequest),
  );
}

export function getBypassIpRequestFromJSON(
  jsonString: string,
): SafeParseResult<GetBypassIpRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetBypassIpRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetBypassIpRequest' from JSON`,
  );
}

/** @internal */
export const GetBypassIpAction$inboundSchema: z.ZodNativeEnum<
  typeof GetBypassIpAction
> = z.nativeEnum(GetBypassIpAction);

/** @internal */
export const GetBypassIpAction$outboundSchema: z.ZodNativeEnum<
  typeof GetBypassIpAction
> = GetBypassIpAction$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetBypassIpAction$ {
  /** @deprecated use `GetBypassIpAction$inboundSchema` instead. */
  export const inboundSchema = GetBypassIpAction$inboundSchema;
  /** @deprecated use `GetBypassIpAction$outboundSchema` instead. */
  export const outboundSchema = GetBypassIpAction$outboundSchema;
}

/** @internal */
export const GetBypassIpResult$inboundSchema: z.ZodType<
  GetBypassIpResult,
  z.ZodTypeDef,
  unknown
> = z.object({
  OwnerId: z.string(),
  Id: z.string(),
  Domain: z.string(),
  Ip: z.string(),
  Action: GetBypassIpAction$inboundSchema.optional(),
  ProjectId: z.string().optional(),
  IsProjectRule: z.boolean().optional(),
  Note: z.string().optional(),
  CreatedAt: z.string(),
  ActorId: z.string().optional(),
  UpdatedAt: z.string(),
  UpdatedAtHour: z.string(),
  DeletedAt: z.string().optional(),
  ExpiresAt: z.nullable(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    "OwnerId": "ownerId",
    "Id": "id",
    "Domain": "domain",
    "Ip": "ip",
    "Action": "action",
    "ProjectId": "projectId",
    "IsProjectRule": "isProjectRule",
    "Note": "note",
    "CreatedAt": "createdAt",
    "ActorId": "actorId",
    "UpdatedAt": "updatedAt",
    "UpdatedAtHour": "updatedAtHour",
    "DeletedAt": "deletedAt",
    "ExpiresAt": "expiresAt",
  });
});

/** @internal */
export type GetBypassIpResult$Outbound = {
  OwnerId: string;
  Id: string;
  Domain: string;
  Ip: string;
  Action?: string | undefined;
  ProjectId?: string | undefined;
  IsProjectRule?: boolean | undefined;
  Note?: string | undefined;
  CreatedAt: string;
  ActorId?: string | undefined;
  UpdatedAt: string;
  UpdatedAtHour: string;
  DeletedAt?: string | undefined;
  ExpiresAt?: number | null | undefined;
};

/** @internal */
export const GetBypassIpResult$outboundSchema: z.ZodType<
  GetBypassIpResult$Outbound,
  z.ZodTypeDef,
  GetBypassIpResult
> = z.object({
  ownerId: z.string(),
  id: z.string(),
  domain: z.string(),
  ip: z.string(),
  action: GetBypassIpAction$outboundSchema.optional(),
  projectId: z.string().optional(),
  isProjectRule: z.boolean().optional(),
  note: z.string().optional(),
  createdAt: z.string(),
  actorId: z.string().optional(),
  updatedAt: z.string(),
  updatedAtHour: z.string(),
  deletedAt: z.string().optional(),
  expiresAt: z.nullable(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    ownerId: "OwnerId",
    id: "Id",
    domain: "Domain",
    ip: "Ip",
    action: "Action",
    projectId: "ProjectId",
    isProjectRule: "IsProjectRule",
    note: "Note",
    createdAt: "CreatedAt",
    actorId: "ActorId",
    updatedAt: "UpdatedAt",
    updatedAtHour: "UpdatedAtHour",
    deletedAt: "DeletedAt",
    expiresAt: "ExpiresAt",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetBypassIpResult$ {
  /** @deprecated use `GetBypassIpResult$inboundSchema` instead. */
  export const inboundSchema = GetBypassIpResult$inboundSchema;
  /** @deprecated use `GetBypassIpResult$outboundSchema` instead. */
  export const outboundSchema = GetBypassIpResult$outboundSchema;
  /** @deprecated use `GetBypassIpResult$Outbound` instead. */
  export type Outbound = GetBypassIpResult$Outbound;
}

export function getBypassIpResultToJSON(
  getBypassIpResult: GetBypassIpResult,
): string {
  return JSON.stringify(
    GetBypassIpResult$outboundSchema.parse(getBypassIpResult),
  );
}

export function getBypassIpResultFromJSON(
  jsonString: string,
): SafeParseResult<GetBypassIpResult, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetBypassIpResult$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetBypassIpResult' from JSON`,
  );
}

/** @internal */
export const GetBypassIpPagination$inboundSchema: z.ZodType<
  GetBypassIpPagination,
  z.ZodTypeDef,
  unknown
> = z.object({
  OwnerId: z.string(),
  Id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "OwnerId": "ownerId",
    "Id": "id",
  });
});

/** @internal */
export type GetBypassIpPagination$Outbound = {
  OwnerId: string;
  Id: string;
};

/** @internal */
export const GetBypassIpPagination$outboundSchema: z.ZodType<
  GetBypassIpPagination$Outbound,
  z.ZodTypeDef,
  GetBypassIpPagination
> = z.object({
  ownerId: z.string(),
  id: z.string(),
}).transform((v) => {
  return remap$(v, {
    ownerId: "OwnerId",
    id: "Id",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetBypassIpPagination$ {
  /** @deprecated use `GetBypassIpPagination$inboundSchema` instead. */
  export const inboundSchema = GetBypassIpPagination$inboundSchema;
  /** @deprecated use `GetBypassIpPagination$outboundSchema` instead. */
  export const outboundSchema = GetBypassIpPagination$outboundSchema;
  /** @deprecated use `GetBypassIpPagination$Outbound` instead. */
  export type Outbound = GetBypassIpPagination$Outbound;
}

export function getBypassIpPaginationToJSON(
  getBypassIpPagination: GetBypassIpPagination,
): string {
  return JSON.stringify(
    GetBypassIpPagination$outboundSchema.parse(getBypassIpPagination),
  );
}

export function getBypassIpPaginationFromJSON(
  jsonString: string,
): SafeParseResult<GetBypassIpPagination, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetBypassIpPagination$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetBypassIpPagination' from JSON`,
  );
}

/** @internal */
export const GetBypassIpResponseBody$inboundSchema: z.ZodType<
  GetBypassIpResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  result: z.array(z.lazy(() => GetBypassIpResult$inboundSchema)),
  pagination: z.lazy(() => GetBypassIpPagination$inboundSchema).optional(),
});

/** @internal */
export type GetBypassIpResponseBody$Outbound = {
  result: Array<GetBypassIpResult$Outbound>;
  pagination?: GetBypassIpPagination$Outbound | undefined;
};

/** @internal */
export const GetBypassIpResponseBody$outboundSchema: z.ZodType<
  GetBypassIpResponseBody$Outbound,
  z.ZodTypeDef,
  GetBypassIpResponseBody
> = z.object({
  result: z.array(z.lazy(() => GetBypassIpResult$outboundSchema)),
  pagination: z.lazy(() => GetBypassIpPagination$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetBypassIpResponseBody$ {
  /** @deprecated use `GetBypassIpResponseBody$inboundSchema` instead. */
  export const inboundSchema = GetBypassIpResponseBody$inboundSchema;
  /** @deprecated use `GetBypassIpResponseBody$outboundSchema` instead. */
  export const outboundSchema = GetBypassIpResponseBody$outboundSchema;
  /** @deprecated use `GetBypassIpResponseBody$Outbound` instead. */
  export type Outbound = GetBypassIpResponseBody$Outbound;
}

export function getBypassIpResponseBodyToJSON(
  getBypassIpResponseBody: GetBypassIpResponseBody,
): string {
  return JSON.stringify(
    GetBypassIpResponseBody$outboundSchema.parse(getBypassIpResponseBody),
  );
}

export function getBypassIpResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<GetBypassIpResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetBypassIpResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetBypassIpResponseBody' from JSON`,
  );
}
